<!-- 
	WebAR_test_15

	
	

	ソースコードを参考にGLTF形式の3Dモデルを取り込み表示
	hittest
	平面を検知して、画面をタップした時に、サークルの位置に3Dモデルが表示される
	タップしたら表示され、前の物は消える → 移動しているように見せる

	r11:複数種類の3Dモデルを表示(ボタンで切換)
			(smallはタップした分生成、mediumはタップするごとに移動)

	切替ボタンがARカメラの映像で隠れてしまう、映像の上に重ねたい


	r12:
	13:モデル二つの表示非表示をそれぞれボタンで制御
	14:モデルの明るさ変更(モデル2のみ)
	15:overlay1の高さがタッチの前後で変化してしまうため、修正中
  16:ミス
	17:




	main.cssコメントアウト

	ソースコード
	https://github.com/mrdoob/three.js/blob/master/examples/jsm/webxr/ARButton.js
	


	・複数の3Dモデルを表示する場合
	3Dファイルを用意します。
	loadModel()関数を複製し、新しい関数を作成します。例えば、loadModel2()という関数を作成します。
	複製した関数内のloader.load()メソッドの第1引数に、新しい3Dファイルのパスを指定します。
	複製した関数内のscene.add()メソッドの引数に、新しいモデルを追加します。
	新しい関数を呼び出すためのイベントリスナーを設定します。例えば、controller.addEventListener('select', loadModel2);というようにします。


	
-->



<!-- 
	WebAR_test_9

	ソースコードを参考にGLTF形式の3Dモデルを取り込み表示
	hittest
	平面を検知して、画面をタップした時に、サークルの位置に3Dモデルが表示される
	タップしたら表示され、前の物は消える → 移動しているように見せる

	ソースコード
	https://github.com/mrdoob/three.js/blob/master/examples/jsm/webxr/ARButton.js
	
-->




<!DOCTYPE html>
<html lang="en">

<head>
	<title>17 three.js ar - hit test</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
	<link type="text/css" rel="stylesheet" href="main.css">
















      <style>
          #marker {
              position: absolute;
              width: 10px;
              height: 10px;
              background: red;
              border-radius: 50%;
              display: none;
              pointer-events: none; /* マーカーをタッチ操作の対象外にする */
          }
      </style>  
</head>

<body>







      <div id="marker"></div>
  
      <script>
          const marker = document.getElementById('marker');
  
          // タッチイベントリッスン
          window.addEventListener('touchstart', (event) => {
              const touch = event.touches[0];
              // タッチ位置にマーカーを表示
              marker.style.left = `${touch.clientX - 5}px`;
              marker.style.top = `${touch.clientY - 5}px`;
              marker.style.display = 'block';
          });
  
          window.addEventListener('touchmove', (event) => {
              const touch = event.touches[0];
              marker.style.left = `${touch.clientX - 5}px`;
              marker.style.top = `${touch.clientY - 5}px`;
          });
  
          window.addEventListener('touchend', () => {
              marker.style.display = 'none';
          });
  
          // DOMの変化を監視するためのMutationObserver
          const targetNode = document.body; // 監視したい要素を指定
  
          const observerCallback = (mutationsList, observer) => {
              for (let mutation of mutationsList) {
                  if (mutation.type === 'childList') {
                      console.log('子ノードの変更が検出されました:', mutation);
                  }
              }
          };
  
          const config = { childList: true, subtree: true }; // 監視オプションを設定
          const observer = new MutationObserver(observerCallback); // MutationObserverのインスタンスを作成
          observer.observe(targetNode, config); // 監視を開始
      </script>












  
</body>

</html>