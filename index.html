<!-- 
	WebAR_test_15

	
	

	ソースコードを参考にGLTF形式の3Dモデルを取り込み表示
	hittest
	平面を検知して、画面をタップした時に、サークルの位置に3Dモデルが表示される
	タップしたら表示され、前の物は消える → 移動しているように見せる

	r11:複数種類の3Dモデルを表示(ボタンで切換)
			(smallはタップした分生成、mediumはタップするごとに移動)

	切替ボタンがARカメラの映像で隠れてしまう、映像の上に重ねたい


	r12:
	13:モデル二つの表示非表示をそれぞれボタンで制御
	14:モデルの明るさ変更(モデル2のみ)
	15:overlay1の高さがタッチの前後で変化してしまうため、修正中
  16:ミス
	17:




	main.cssコメントアウト

	ソースコード
	https://github.com/mrdoob/three.js/blob/master/examples/jsm/webxr/ARButton.js
	


	・複数の3Dモデルを表示する場合
	3Dファイルを用意します。
	loadModel()関数を複製し、新しい関数を作成します。例えば、loadModel2()という関数を作成します。
	複製した関数内のloader.load()メソッドの第1引数に、新しい3Dファイルのパスを指定します。
	複製した関数内のscene.add()メソッドの引数に、新しいモデルを追加します。
	新しい関数を呼び出すためのイベントリスナーを設定します。例えば、controller.addEventListener('select', loadModel2);というようにします。


	
-->



<!-- 
	WebAR_test_9

	ソースコードを参考にGLTF形式の3Dモデルを取り込み表示
	hittest
	平面を検知して、画面をタップした時に、サークルの位置に3Dモデルが表示される
	タップしたら表示され、前の物は消える → 移動しているように見せる

	ソースコード
	https://github.com/mrdoob/three.js/blob/master/examples/jsm/webxr/ARButton.js
	
-->







  


<!DOCTYPE html>
<html lang="en">
<head>

  <link type="text/css" rel="stylesheet" href="main.css">
  
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>17 three.js ar - hit test</title>

    <style>
        canvas { display: block; }
        #marker {
            position: absolute;
            width: 10px;
            height: 10px;
            background: red;
            border-radius: 50%;
            display: none;
        }
    </style>
</head>
<body>
    <div id="marker"></div>
    <script src="https://threejs.org/build/three.js"></script>
    <script src="https://threejs.org/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://aframe.io/releases/1.2.0/aframe.min.js"></script>
    <script src="https://aframe.io/releases/1.2.0/aframe-ar.js"></script>

    <script>
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const loader = new THREE.GLTFLoader();

        // タッチイベントリスナー
        window.addEventListener('touchstart', (event) => {
            const touch = event.touches[0];
            const marker = document.getElementById('marker');
            marker.style.left = `${touch.clientX - 5}px`;
            marker.style.top = `${touch.clientY - 5}px`;
            marker.style.display = 'block';

            // 2Dタッチ位置を3D空間に変換
            const rect = renderer.domElement.getBoundingClientRect();
            const x = ((touch.clientX - rect.left) / rect.width) * 2 - 1;
            const y = -((touch.clientY - rect.top) / rect.height) * 2 + 1;

            // Raycasterを使ってオブジェクトを配置
            const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2(x, y);
            raycaster.setFromCamera(mouse, camera);

            // 衝突オブジェクトの取得
            const intersects = raycaster.intersectObjects(scene.children);
            if (intersects.length > 0) {
                const point = intersects[0].point;
                // オブジェクトを配置
                loader.load('cube_small.glb', (gltf) => {
                    const object = gltf.scene;
                    object.position.copy(point);
                    scene.add(object);
                });
            }
        });

        // アニメーションループ
        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }
        animate();
    </script>
</body>
</html>





